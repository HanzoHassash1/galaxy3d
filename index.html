<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Galáxia de Amor</title>
<style>
  html, body {
    height: 100%;
    margin: 0;
    background: #000;
    overflow: hidden;
    font-family: 'Poppins', system-ui, sans-serif;
    color: #fff;
  }
  #container {
    width: 100%;
    height: 100%;
    position: fixed;
    inset: 0;
    display: block;
  }
  .word-label {
    position: absolute;
    transform: translate(-50%, -50%);
    color: #ffffff;
    font-weight: 600;
    text-shadow: 0 0 5px rgba(255, 255, 255, 0.5), 0 0 15px rgba(255, 165, 0, 0.4);
    font-size: 16px;
    white-space: nowrap;
    pointer-events: none;
    transition: opacity 0.3s ease;
  }
  #overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    z-index: 100;
    cursor: pointer;
    transition: opacity 0.5s ease;
  }
  #overlay h1 {
    font-size: 2.5em;
    margin: 0;
    letter-spacing: 2px;
    background: linear-gradient(90deg, #ffae00, #ff5f00);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }
  #overlay p {
    font-size: 1.2em;
    margin-top: 10px;
    color: #ccc;
  }
</style>
</head>
<body>

<div id="container"></div>

<div id="overlay">
  <h1>Nossa Galáxia</h1>
  <p>Clique para iniciar</p>
</div>

<!-- 
  IMPORT MAP: A solução definitiva.
  Isto diz ao navegador "onde encontrar" as bibliotecas quando usamos a palavra 'import'.
  Ele resolve todos os problemas de carregamento e ordem.
-->
<script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
    }
  }
</script>

<!-- 
  SCRIPT PRINCIPAL COMO MÓDULO:
  Agora, o nosso código principal é um "módulo", o que lhe permite usar 'import'.
-->
<script type="module">
    // Importamos as bibliotecas explicitamente. O navegador espera que elas carreguem.
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const PHRASES = [
      "Meu Amor", "Minha Vida", "Te Amo", "Para Sempre", "Meu Tudo", 

      "Alma Gêmea", "Meu Porto Seguro", "Juntos", "Meu Coração é Seu", 

      "Meu Sol", "Minha Estrela", "Infinito", "Nós Dois", "Felicidade", 

      "Carinho", "Paixão", "Eterno", "Meu Anjo", "Meu Tesouro", "Minha Gatinha",

      "Minha Linda", "Melhor Esposa"
    ];

    let scene, camera, renderer, controls;
    const words = [];
    let isInitialized = false;
    let accretionDisk; // Variável para o disco de acreção

    const overlay = document.getElementById('overlay');
    const container = document.getElementById('container');

    overlay.addEventListener('click', () => {
      if (isInitialized) return;
      isInitialized = true;

      overlay.style.opacity = '0';
      setTimeout(() => {
        overlay.style.display = 'none';
      }, 500);
      
      init();
      animate();
    });

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 100;

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      container.appendChild(renderer.domElement);
      
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.screenSpacePanning = false;
      controls.minDistance = 20;
      controls.maxDistance = 250;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.3;
      
      // Uma luz ambiente suave para que as palavras sejam visíveis
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
      scene.add(ambientLight);

      createStarfield();
      createBlackHole(); // Função alterada
      createFloatingWords();

      window.addEventListener('resize', onWindowResize);
    }

    function createStarfield() {
      const starGeometry = new THREE.BufferGeometry();
      const starCount = 5000;
      const posArray = new Float32Array(starCount * 3);
      for (let i = 0; i < starCount; i++) {
          const u = Math.random();
          const v = Math.random();
          const theta = 2 * Math.PI * u;
          const phi = Math.acos(2 * v - 1);
          const r = 300 + Math.random() * 200;
          posArray[i * 3] = r * Math.sin(phi) * Math.cos(theta);
          posArray[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
          posArray[i * 3 + 2] = r * Math.cos(phi);
      }
      starGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
      const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.7, transparent: true, opacity: 0.8 });
      const starMesh = new THREE.Points(starGeometry, starMaterial);
      scene.add(starMesh);
    }
    
    // Nova função para criar o buraco negro e o disco de acreção
    function createBlackHole() {
      // A esfera central preta
      const blackHoleGeometry = new THREE.SphereGeometry(10, 64, 64);
      const blackHoleMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
      const blackHole = new THREE.Mesh(blackHoleGeometry, blackHoleMaterial);
      scene.add(blackHole);

      // Função para criar a textura do disco de acreção
      function createAccretionDiskTexture() {
          const canvas = document.createElement('canvas');
          canvas.width = 256;
          canvas.height = 256;
          const context = canvas.getContext('2d');
          const gradient = context.createRadialGradient(128, 128, 50, 128, 128, 128);
          gradient.addColorStop(0.3, 'rgba(255, 200, 100, 1)');
          gradient.addColorStop(0.6, 'rgba(255, 100, 0, 0.8)');
          gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
          context.fillStyle = gradient;
          context.fillRect(0, 0, 256, 256);
          return new THREE.CanvasTexture(canvas);
      }

      // Geometria e material do disco
      const accretionDiskTexture = createAccretionDiskTexture();
      const accretionDiskGeometry = new THREE.RingGeometry(11, 35, 128);
      const accretionDiskMaterial = new THREE.MeshBasicMaterial({
          map: accretionDiskTexture,
          side: THREE.DoubleSide,
          transparent: true,
          blending: THREE.AdditiveBlending // Efeito de brilho
      });
      accretionDisk = new THREE.Mesh(accretionDiskGeometry, accretionDiskMaterial);
      accretionDisk.rotation.x = Math.PI / 2.1;
      accretionDisk.name = "accretionDisk";
      scene.add(accretionDisk);
    }

    function createFloatingWords() {
      PHRASES.forEach(text => {
        const label = document.createElement('div');
        label.className = 'word-label';
        label.textContent = text;
        document.body.appendChild(label);
        const radius = 40 + Math.random() * 60; // Aumentar raio para não colidir com o disco
        const speed = (0.0002 + Math.random() * 0.0005) * (Math.random() > 0.5 ? 1 : -1);
        const angle = Math.random() * Math.PI * 2;
        const yOffset = (Math.random() - 0.5) * 40;
        words.push({ label, radius, speed, angle, yOffset, baseOpacity: 0.5 + Math.random() * 0.5, position: new THREE.Vector3() });
      });
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function updateWordLabels() {
      words.forEach(word => {
        word.angle += word.speed * 16.67;
        const x = Math.cos(word.angle) * word.radius;
        const z = Math.sin(word.angle) * word.radius;
        word.position.set(x, word.yOffset, z);

        const screenPosition = word.position.clone().project(camera);
        const screenX = (screenPosition.x + 1) * window.innerWidth / 2;
        const screenY = (-screenPosition.y + 1) * window.innerHeight / 2;
        word.label.style.transform = `translate(-50%, -50%) translate(${screenX}px, ${screenY}px)`;
        
        const distanceToCamera = camera.position.distanceTo(word.position);
        if (screenPosition.z > 1) {
            word.label.style.opacity = 0;
        } else {
            const opacity = Math.max(0, 1 - (distanceToCamera / 200)) * word.baseOpacity;
            word.label.style.opacity = opacity;
        }
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();

      // Animar a rotação do disco de acreção
      if (accretionDisk) {
        accretionDisk.rotation.z -= 0.002;
      }

      updateWordLabels();
      renderer.render(scene, camera);
    }
</script>
</body>
</html>

