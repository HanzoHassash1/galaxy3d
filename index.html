<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Galáxia de Amor</title>
<style>
  html, body {
    height: 100%;
    margin: 0;
    background: #000;
    overflow: hidden;
    font-family: 'Poppins', system-ui, sans-serif;
    color: #fff;
  }
  #container {
    width: 100%;
    height: 100%;
    position: fixed;
    inset: 0;
    display: block;
  }
  .word-label {
    position: absolute;
    transform: translate(-50%, -50%);
    color: #ffffff;
    font-weight: 600;
    text-shadow: 0 0 5px rgba(255, 255, 255, 0.5), 0 0 15px rgba(255, 165, 0, 0.4);
    font-size: 16px;
    white-space: nowrap;
    pointer-events: none;
    transition: opacity 0.3s ease;
  }
  #overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    z-index: 100;
    cursor: pointer;
    transition: opacity 0.5s ease;
  }
  #overlay h1 {
    font-size: 2.5em;
    margin: 0;
    letter-spacing: 2px;
    background: linear-gradient(90deg, #ffae00, #ff5f00);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }
  #overlay p {
    font-size: 1.2em;
    margin-top: 10px;
    color: #ccc;
  }
</style>
</head>
<body>

<div id="container"></div>

<div id="overlay">
  <h1>Galáxia de Amor</h1>
  <p>Clique para iniciar</p>
</div>

<script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
    }
  }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const PHRASES = [
      "Meu Amor", "Minha Vida", "Te Amo", "Para Sempre", "Meu Tudo", 
      "Alma Gêmea", "Meu Porto Seguro", "Juntos", "Meu Coração é Seu", 
      "Meu Sol", "Minha Estrela", "Infinito", "Nós Dois", "Felicidade", 
      "Carinho", "Paixão", "Eterno", "Meu Anjo", "Meu Tesouro"
    ];

    let scene, camera, renderer, controls;
    const words = [];
    let isInitialized = false;
    let nebulaCloud, accretionDiskParticles; 

    const overlay = document.getElementById('overlay');
    const container = document.getElementById('container');

    overlay.addEventListener('click', () => {
      if (isInitialized) return;
      isInitialized = true;

      overlay.style.opacity = '0';
      setTimeout(() => {
        overlay.style.display = 'none';
      }, 500);
      
      init();
      animate();
    });

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
      camera.position.z = 100;
      
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      container.appendChild(renderer.domElement);
      
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.screenSpacePanning = false;
      controls.minDistance = 20;
      controls.maxDistance = 600; 
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.2;
      
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
      scene.add(ambientLight);

      createNebulaCloud();
      createStarfield();
      createBlackHole();
      createFloatingWords();

      window.addEventListener('resize', onWindowResize);
    }

    function createNebulaCloud() {
        const loader = new THREE.TextureLoader();
        loader.load(
            './nebula.jpg', 
            (texture) => {
                const img = texture.image;
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;

                const geometry = new THREE.BufferGeometry();
                const positions = [];
                const colors = [];

                const density = 2;
                for (let y = 0; y < canvas.height; y += density) {
                    for (let x = 0; x < canvas.width; x += density) {
                        const i = (y * canvas.width + x) * 4;
                        const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                        if (brightness > 20) {
                            const pX = (x - canvas.width / 2) * 1.5;
                            const pY = -(y - canvas.height / 2) * 1.5;
                            const pZ = (Math.random() - 0.5) * 50;
                            positions.push(pX, pY, pZ);
                            const r = data[i] / 255;
                            const g = data[i + 1] / 255;
                            const b = data[i + 2] / 255;
                            colors.push(r, g, b);
                        }
                    }
                }
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 1.5,
                    vertexColors: true,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 0.7,
                    depthWrite: false,
                });

                nebulaCloud = new THREE.Points(geometry, material);
                nebulaCloud.position.set(0, 0, -500);
                scene.add(nebulaCloud);
            },
            undefined, 
            (err) => {
                console.error('Ocorreu um erro ao carregar a textura da nebulosa:', err);
            }
        );
    }

    function createStarfield() {
      const starGeometry = new THREE.BufferGeometry();
      const starCount = 2000;
      const posArray = new Float32Array(starCount * 3);
      for (let i = 0; i < starCount; i++) {
          const u = Math.random();
          const v = Math.random();
          const theta = 2 * Math.PI * u;
          const phi = Math.acos(2 * v - 1);
          const r = 400 + Math.random() * 500;
          posArray[i * 3] = r * Math.sin(phi) * Math.cos(theta);
          posArray[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
          posArray[i * 3 + 2] = r * Math.cos(phi);
      }
      starGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
      const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.9, transparent: true, opacity: 0.8 });
      const starMesh = new THREE.Points(starGeometry, starMaterial);
      scene.add(starMesh);
    }
    
    function createBlackHole() {
      // Esfera preta central
      const blackHoleGeometry = new THREE.SphereGeometry(10, 64, 64);
      const blackHoleMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
      const blackHole = new THREE.Mesh(blackHoleGeometry, blackHoleMaterial);
      scene.add(blackHole);

      // Disco de acreção com partículas
      const particlesGeometry = new THREE.BufferGeometry();
      const particlesCount = 300000;
      const posArray = new Float32Array(particlesCount * 6);
      const colors = new Float32Array(particlesCount * 6);

      for (let i = 0; i < particlesCount; i++) {
        const radius = 12 + Math.random() * 25;
        const angle = Math.random() * Math.PI * 2;
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        const y = (Math.random() - 0.5) * 3; // Ligeira espessura no disco

        posArray[i * 3] = x;
        posArray[i * 3 + 1] = y;
        posArray[i * 3 + 2] = z;

        // Cor varia com a distância
        const color = new THREE.Color();
        const innerColor = new THREE.Color(0xffffff); // Branco perto
        const outerColor = new THREE.Color(0xffa500); // Laranja longe
        color.lerpColors(innerColor, outerColor, (radius - 12) / 25);
        colors[i * 3] = color.r;
        colors[i * 3 + 1] = color.g;
        colors[i * 3 + 2] = color.b;
      }

      particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
      particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      const particlesMaterial = new THREE.PointsMaterial({
        size: 0.2,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        transparent: true,
        opacity: 0.9,
        depthWrite: false,
      });

      accretionDiskParticles = new THREE.Points(particlesGeometry, particlesMaterial);
      accretionDiskParticles.rotation.x = Math.PI / 18;
      scene.add(accretionDiskParticles);
    }

    function createFloatingWords() {
      PHRASES.forEach(text => {
        const label = document.createElement('div');
        label.className = 'word-label';
        label.textContent = text;
        document.body.appendChild(label);
        const radius = 70 + Math.random() * 60; 
        const speed = (0.0002 + Math.random() * 0.0005) * (Math.random() > 0.5 ? 1 : -1);
        const angle = Math.random() * Math.PI * 2;
        const yOffset = (Math.random() - 0.5) * 40;
        words.push({ label, radius, speed, angle, yOffset, baseOpacity: 0.5 + Math.random() * 0.5, position: new THREE.Vector3() });
      });
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function updateWordLabels() {
      words.forEach(word => {
        word.angle += word.speed * 16.67;
        const x = Math.cos(word.angle) * word.radius;
        const z = Math.sin(word.angle) * word.radius;
        word.position.set(x, word.yOffset, z);

        const screenPosition = word.position.clone().project(camera);
        const screenX = (screenPosition.x + 1) * window.innerWidth / 2;
        const screenY = (-screenPosition.y + 1) * window.innerHeight / 2;
        word.label.style.transform = `translate(-50%, -50%) translate(${screenX}px, ${screenY}px)`;
        
        const distanceToCamera = camera.position.distanceTo(word.position);
        if (screenPosition.z > 1) {
            word.label.style.opacity = 0;
        } else {
            const opacity = Math.max(0, 1 - (distanceToCamera / 200)) * word.baseOpacity;
            word.label.style.opacity = opacity;
        }
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();

      if (nebulaCloud) {
        nebulaCloud.rotation.y += 0.0001;
      }
      
      if (accretionDiskParticles) {
        accretionDiskParticles.rotation.y -= 0.002;
      }

      updateWordLabels();
      renderer.render(scene, camera);
    }
</script>
</body>
</html>

