<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Galáxia de Amor</title>
<style>
  html, body {
    height: 100%;
    margin: 0;
    background: #000;
    overflow: hidden;
    font-family: 'Poppins', system-ui, sans-serif;
    color: #fff;
  }
  #container {
    width: 100%;
    height: 100%;
    position: fixed;
    inset: 0;
    display: block;
  }
  .word-label {
    position: absolute;
    transform: translate(-50%, -50%);
    color: #ffffff;
    font-weight: 600;
    text-shadow: 0 0 5px rgba(255, 255, 255, 0.5), 0 0 15px rgba(255, 165, 0, 0.4);
    font-size: 16px;
    white-space: nowrap;
    pointer-events: none;
    transition: opacity 0.3s ease;
  }
  #overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    z-index: 100;
    cursor: pointer;
    transition: opacity 0.5s ease;
  }
  #overlay h1 {
    font-size: 2.5em;
    margin: 0;
    letter-spacing: 2px;
    background: linear-gradient(90deg, #ffae00, #ff5f00);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }
  #overlay p {
    font-size: 1.2em;
    margin-top: 10px;
    color: #ccc;
  }
</style>
</head>
<body>

<div id="container"></div>

<div id="overlay">
  <h1>Galáxia de Amor</h1>
  <p>Clique para iniciar</p>
</div>

<script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
    }
  }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const PHRASES = [
      "Meu Amor", "Minha Vida", "Te Amo", "Para Sempre", "Meu Tudo", 
      "Alma Gêmea", "Meu Porto Seguro", "Juntos", "Meu Coração é Seu", 
      "Meu Sol", "Minha Estrela", "Infinito", "Nós Dois", "Felicidade", 
      "Carinho", "Paixão", "Eterno", "Meu Anjo", "Meu Tesouro"
    ];

    let scene, camera, renderer, controls;
    const words = [];
    let isInitialized = false;
    let nebulaCloud, blackHolePlane; 

    // A imagem da nebulosa, agora embutida como texto (Base64)
    const nebulaBase64 = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAQAAwADASIAAhEBAxEB/8QAHAAAAQUBAQEAAAAAAAAAAAAAAgABAwQFBgcI/8QAVxAAAQMCBAQDBgMEBgcFBgMJEQECAxEEBRIhMQZBUSITYXEigZEyobEHFEJSctFioeHwM2NzgpKywhUkQ3OiwvElNERUY4STo9NUVaPDF0Vlc4T/xAAaAQEBAQEBAQEAAAAAAAAAAAAAAQIDBAUG/8QALxEBAQACAgEDAwMDBAMBAQEAAAECEQMhEjFBBBMiURRhcUKBkaGxMhXwUsHR4f/aAAwDAQACEQMRAD8A6fV6jI6Z0c8L2ujc1SAaUqc0Vw7n0Kj+0P/wBwf5W/vXz3N6t3E8m03Jg3l/V5d+X3189mS+e43lZceWf/Vb0Z20D2h/+4P8AK396faH/AO4P8rf3r57mZJxu/wAp9y+zP/r2P2h/+4P8rf3p9of/ALg/yt/evnuZkmN3+Ue5fZf9ex+0P/3B/lb+9PtD/wDcH+Vv7189zMkxv/yj3L7L/r2P2h/+4P8AK396faH/AO4P8rf3r57mZJjf/lHuX2X/AF7H7Q//AHB/lb+9PtD/APcH+Vv7189zMkxv/wAqPcvsv+vY/aH/AO4P8rf3p9of/uD/ACt/evnuZkmN/+Ue5fZf9ex+0P8A9wf5W/vT7Q//AHB/lb+9fPczJMb/APKPcvsv+vY/aH/7g/yt/en2h/8AuD/K396+e5mSY3/5R7l9l/17H7Q//cH+Vv70+0P/ANwf5W/vXz3MyTG//KPcvsv+vY/aH/7g/wArf3p9of8A7g/yt/evnuZkmN/+Ue5fZf8AXsftD/8AcH+Vv70+0P8A9wf5W/vXz3MyTG//ACj3L7L/AK9j9of/ALg/yt/en2h/+4P8rf3r57mZJjf/AJR7l9l/17H7Q/8A3B/lb+9PtD/9wf5W/vXz3MyTG/8Ayj3L7L/r2P2h/wDuD/K396faH/7g/wArf3r57mZJjf8A5R7l9l/17H7Q/wD3B/lb+9PtD/8AcH+Vv7189zMkxv8A8o9y+y/69j9of/uD/K396faH/wC4P8rf3r57mZJjf/lHuX2X/Xsf/9k=";

    const overlay = document.getElementById('overlay');
    const container = document.getElementById('container');

    overlay.addEventListener('click', () => {
      if (isInitialized) return;
      isInitialized = true;

      overlay.style.opacity = '0';
      setTimeout(() => {
        overlay.style.display = 'none';
      }, 500);
      
      init();
      animate();
    });

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
      camera.position.z = 100;
      
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      container.appendChild(renderer.domElement);
      
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.screenSpacePanning = false;
      controls.minDistance = 20;
      controls.maxDistance = 600; 
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.2;
      
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
      scene.add(ambientLight);

      createNebulaCloud();
      createStarfield();
      createBlackHole();
      createFloatingWords();

      window.addEventListener('resize', onWindowResize);
    }

    function createNebulaCloud() {
        const loader = new THREE.TextureLoader();
        // Carregar a imagem a partir do texto Base64
        loader.load(
            nebulaBase64, 
            (texture) => {
                const img = texture.image;
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;

                const geometry = new THREE.BufferGeometry();
                const positions = [];
                const colors = [];

                const density = 2;
                for (let y = 0; y < canvas.height; y += density) {
                    for (let x = 0; x < canvas.width; x += density) {
                        const i = (y * canvas.width + x) * 4;
                        const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
                        if (brightness > 10) { // Limiar de brilho baixo
                            const pX = (x - canvas.width / 2) * 1.5;
                            const pY = -(y - canvas.height / 2) * 1.5;
                            const pZ = (Math.random() - 0.5) * 50;
                            positions.push(pX, pY, pZ);

                            const r = data[i] / 255;
                            const g = data[i + 1] / 255;
                            const b = data[i + 2] / 255;
                            colors.push(r, g, b);
                        }
                    }
                }

                geometry.setAttribute('position', new THREE.Float33BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 1.5,
                    vertexColors: true,
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    opacity: 0.7,
                    depthWrite: false,
                });

                nebulaCloud = new THREE.Points(geometry, material);
                nebulaCloud.position.set(0, 0, -500);
                scene.add(nebulaCloud);
            },
            undefined, 
            (err) => {
                console.error('Ocorreu um erro ao carregar a textura da nebulosa:', err);
            }
        );
    }

    function createStarfield() {
      const starGeometry = new THREE.BufferGeometry();
      const starCount = 2000;
      const posArray = new Float32Array(starCount * 3);
      for (let i = 0; i < starCount; i++) {
          const u = Math.random();
          const v = Math.random();
          const theta = 2 * Math.PI * u;
          const phi = Math.acos(2 * v - 1);
          const r = 400 + Math.random() * 500;
          posArray[i * 3] = r * Math.sin(phi) * Math.cos(theta);
          posArray[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
          posArray[i * 3 + 2] = r * Math.cos(phi);
      }
      starGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
      const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.9, transparent: true, opacity: 0.8 });
      const starMesh = new THREE.Points(starGeometry, starMaterial);
      scene.add(starMesh);
    }
    
    function createBlackHole() {
      const loader = new THREE.TextureLoader();
      loader.load('./blackhole.jpg', (texture) => {
        const planeGeometry = new THREE.PlaneGeometry(120, 60);
        const planeMaterial = new THREE.MeshBasicMaterial({
          map: texture,
          transparent: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false, 
        });
        
        blackHolePlane = new THREE.Mesh(planeGeometry, planeMaterial);
        blackHolePlane.rotation.x = Math.PI / 18;
        scene.add(blackHolePlane);
      });
    }

    function createFloatingWords() {
      PHRASES.forEach(text => {
        const label = document.createElement('div');
        label.className = 'word-label';
        label.textContent = text;
        document.body.appendChild(label);
        const radius = 70 + Math.random() * 60; 
        const speed = (0.0002 + Math.random() * 0.0005) * (Math.random() > 0.5 ? 1 : -1);
        const angle = Math.random() * Math.PI * 2;
        const yOffset = (Math.random() - 0.5) * 40;
        words.push({ label, radius, speed, angle, yOffset, baseOpacity: 0.5 + Math.random() * 0.5, position: new THREE.Vector3() });
      });
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function updateWordLabels() {
      words.forEach(word => {
        word.angle += word.speed * 16.67;
        const x = Math.cos(word.angle) * word.radius;
        const z = Math.sin(word.angle) * word.radius;
        word.position.set(x, word.yOffset, z);

        const screenPosition = word.position.clone().project(camera);
        const screenX = (screenPosition.x + 1) * window.innerWidth / 2;
        const screenY = (-screenPosition.y + 1) * window.innerHeight / 2;
        word.label.style.transform = `translate(-50%, -50%) translate(${screenX}px, ${screenY}px)`;
        
        const distanceToCamera = camera.position.distanceTo(word.position);
        if (screenPosition.z > 1) {
            word.label.style.opacity = 0;
        } else {
            const opacity = Math.max(0, 1 - (distanceToCamera / 200)) * word.baseOpacity;
            word.label.style.opacity = opacity;
        }
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();

      if (nebulaCloud) {
        nebulaCloud.rotation.y += 0.0001;
      }
      
      if (blackHolePlane) {
        blackHolePlane.rotation.z -= 0.0005;
      }

      updateWordLabels();
      renderer.render(scene, camera);
    }
</script>
</body>
</html>

