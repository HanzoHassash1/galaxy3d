<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Galáxia de Amor</title>
<style>
  html, body {
    height: 100%;
    margin: 0;
    background: #000;
    overflow: hidden;
    font-family: 'Poppins', system-ui, sans-serif;
    color: #fff;
  }
  #container {
    width: 100%;
    height: 100%;
    position: fixed;
    inset: 0;
    display: block;
  }
  .word-label {
    position: absolute;
    transform: translate(-50%, -50%);
    color: #ffffff;
    font-weight: 600;
    text-shadow: 0 0 5px rgba(255, 255, 255, 0.5), 0 0 15px rgba(255, 165, 0, 0.4);
    font-size: 16px;
    white-space: nowrap;
    pointer-events: none; /* Impede que os textos bloqueiem o clique do mouse */
    transition: opacity 0.3s ease;
  }
  #overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    z-index: 100;
    cursor: pointer;
    transition: opacity 0.5s ease;
  }
  #overlay h1 {
    font-size: 2.5em;
    margin: 0;
    letter-spacing: 2px;
    background: linear-gradient(90deg, #ffae00, #ff5f00);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }
  #overlay p {
    font-size: 1.2em;
    margin-top: 10px;
    color: #ccc;
  }
</style>
</head>
<body>

<div id="container"></div>

<div id="overlay">
  <h1>Galáxia de Amor</h1>
  <p>Clique para iniciar</p>
</div>

<!-- Você pode trocar o "src" por qualquer link de música que desejar -->
<audio id="music" loop src="https://cdn.pixabay.com/audio/2023/10/11/audio_1451e3c84e.mp3"></audio>

<!-- Bibliotecas Three.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/controls/OrbitControls.js"></script>

<script>
  // Lista de frases que irão orbitar
  const PHRASES = [
    "Meu Amor", "Minha Vida", "Te Amo", "Para Sempre", "Meu Tudo", 
    "Alma Gêmea", "Meu Porto Seguro", "Juntos", "Meu Coração é Seu", 
    "Meu Sol", "Minha Estrela", "Infinito", "Nós Dois", "Felicidade", 
    "Carinho", "Paixão", "Eterno", "Meu Anjo", "Meu Tesouro"
  ];

  let scene, camera, renderer, controls;
  const words = [];

  const overlay = document.getElementById('overlay');
  const music = document.getElementById('music');
  const container = document.getElementById('container');

  // A cena só inicia após o clique do usuário
  overlay.addEventListener('click', () => {
    overlay.style.opacity = '0';
    setTimeout(() => {
      overlay.style.display = 'none';
    }, 500);

    music.volume = 0.5;
    music.play();
    
    init();
    animate();
  });

  function init() {
    // --- Cena e Câmera ---
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 100;

    // --- Renderizador ---
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    // --- Controles de Câmera ---
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;
    controls.minDistance = 20;
    controls.maxDistance = 250;
    controls.autoRotate = true; // Faz a cena girar sozinha
    controls.autoRotateSpeed = 0.3;

    // --- Luzes ---
    const pointLight = new THREE.PointLight(0xffaa55, 2, 500);
    scene.add(pointLight);
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
    scene.add(ambientLight);

    // --- Elementos da Cena ---
    createStarfield();
    createCentralBody();
    createFloatingWords();

    // --- Redimensionamento da Janela ---
    window.addEventListener('resize', onWindowResize);
  }

  function createStarfield() {
    const starGeometry = new THREE.BufferGeometry();
    const starCount = 5000;
    const posArray = new Float32Array(starCount * 3);

    for (let i = 0; i < starCount; i++) {
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1);
        const r = 300 + Math.random() * 200;
        
        posArray[i * 3] = r * Math.sin(phi) * Math.cos(theta);
        posArray[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
        posArray[i * 3 + 2] = r * Math.cos(phi);
    }

    starGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
    const starMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.7,
        transparent: true,
        opacity: 0.8
    });
    const starMesh = new THREE.Points(starGeometry, starMaterial);
    scene.add(starMesh);
  }
  
  function createCentralBody() {
    // Sol
    const sunGeometry = new THREE.SphereGeometry(10, 32, 32);
    const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffdd88 });
    const sun = new THREE.Mesh(sunGeometry, sunMaterial);
    scene.add(sun);

    // Anel
    const ringGeometry = new THREE.TorusGeometry(20, 1.5, 2, 100);
    const ringMaterial = new THREE.MeshBasicMaterial({ 
      color: 0xffdd88, 
      side: THREE.DoubleSide,
      transparent: true,
      opacity: 0.8
    });
    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
    ring.rotation.x = Math.PI / 2.2;
    scene.add(ring);
  }

  function createFloatingWords() {
    PHRASES.forEach(text => {
      const label = document.createElement('div');
      label.className = 'word-label';
      label.textContent = text;
      document.body.appendChild(label);

      const radius = 30 + Math.random() * 60; // Distância do centro
      const speed = (0.0002 + Math.random() * 0.0005) * (Math.random() > 0.5 ? 1 : -1);
      const angle = Math.random() * Math.PI * 2;
      const yOffset = (Math.random() - 0.5) * 40; // Variação de altura

      words.push({
        label,
        radius,
        speed,
        angle,
        yOffset,
        baseOpacity: 0.5 + Math.random() * 0.5,
        // Vetor 3D para guardar a posição no espaço
        position: new THREE.Vector3() 
      });
    });
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function updateWordLabels() {
    words.forEach(word => {
      // Atualiza o ângulo para fazer a órbita
      word.angle += word.speed * (16.67); // Movimento constante

      // Calcula a nova posição 3D
      const x = Math.cos(word.angle) * word.radius;
      const z = Math.sin(word.angle) * word.radius;
      word.position.set(x, word.yOffset, z);

      // Projeta a posição 3D para a tela 2D
      const screenPosition = word.position.clone().project(camera);
      const screenX = (screenPosition.x + 1) * window.innerWidth / 2;
      const screenY = (-screenPosition.y + 1) * window.innerHeight / 2;
      
      // Atualiza a posição do elemento HTML
      word.label.style.transform = `translate(-50%, -50%) translate(${screenX}px, ${screenY}px)`;
      
      // Esconde o texto se ele estiver atrás da câmera
      const distanceToCamera = camera.position.distanceTo(word.position);
      // O valor de z após a projeção nos diz se está na frente (z < 1) ou atrás (z > 1)
      if (screenPosition.z > 1) {
          word.label.style.opacity = 0;
      } else {
          // Fade com base na distância
          const opacity = Math.max(0, 1 - (distanceToCamera / 200)) * word.baseOpacity;
          word.label.style.opacity = opacity;
      }
    });
  }

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    updateWordLabels();
    renderer.render(scene, camera);
  }
</script>
</body>
</html>

